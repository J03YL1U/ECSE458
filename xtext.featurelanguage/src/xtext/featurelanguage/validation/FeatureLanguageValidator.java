/*
 * generated by Xtext 2.32.0
 */
package xtext.featurelanguage.validation;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

import xtext.featurelanguage.featureLanguage.Characteristic;
import xtext.featurelanguage.featureLanguage.Concept;
import xtext.featurelanguage.featureLanguage.ConceptProperty;
import xtext.featurelanguage.featureLanguage.FeatureLanguagePackage;
import xtext.featurelanguage.featureLanguage.FeatureList;
import xtext.featurelanguage.featureLanguage.Key;
import xtext.featurelanguage.featureLanguage.KeyType;
import xtext.featurelanguage.featureLanguage.Property;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class FeatureLanguageValidator extends AbstractFeatureLanguageValidator {
	
	@Check
	public void checkOnlyOneKeyPerConcept(Key key) {
		FeatureList featureList = (FeatureList) key.eContainer();

		if (featureList != null) {
			if (key.getKeyType().equals(KeyType.AUTOUNIQUE) || key.getKeyType().equals(KeyType.UNIQUE)) {
				for (Key otherKey : featureList.getKeys()) {
					if (!key.equals(otherKey) && key.getConcept().equals(otherKey.getConcept())) {
						if (!otherKey.getKeyType().equals(KeyType.INDEX)) {
							error("There can only be one key per concept",
									FeatureLanguagePackage.Literals.KEY__CONCEPT);
							break;
						}
					}
				}
			}
			for (Key otherKey : featureList.getKeys()) {
				if (!key.equals(otherKey) && key.getConcept().equals(otherKey.getConcept()) && key.getCharacteristic().equals(otherKey.getCharacteristic())) {
					error("There can only be one key per concept",
							FeatureLanguagePackage.Literals.KEY__CONCEPT);
					break;
				}
				if (!key.equals(otherKey) && key.getConcept().getName().toString().equals(otherKey.getCharacteristic().getType().getName().toString())) {
					error("There can only be one key per concept",
							FeatureLanguagePackage.Literals.KEY__CONCEPT);
					break;
				}
			}
		}
	}
	
	@Check
	public void checkEachIndexKeyHasConcept(Key key) {
		FeatureList featureList = (FeatureList) key.eContainer();

		if (featureList != null) {
			if (key.getKeyType().equals(KeyType.INDEX)) {
				EList<Concept> concepts = featureList.getConcepts();
				boolean hasConcept = false;
				for (Concept concept : concepts) {
					if (key.getCharacteristic().getType().getName().toString().equals(concept.getName().toString())) {
						hasConcept = true;
					}
				}
				if (!hasConcept) {
					error("Every key needs a concept",
							FeatureLanguagePackage.Literals.KEY__CHARACTERISTIC);
				}
			}
		}
	}

	@Check
	public void checkEachConceptButRootHasKey(Concept concept) {
		FeatureList featureList = (FeatureList) concept.eContainer();
		Concept rootConcept = null;
		if (featureList != null) {
			EList<Property> properties = featureList.getProperties();
			for (Property property : properties) {
				if (property instanceof ConceptProperty) {
					rootConcept = property.getConcept();
				}
			}
		}
		if (!concept.equals(rootConcept)) {
			boolean hasKey = false;

			if (featureList != null) {
				for (Key key : featureList.getKeys()) {
					if (key.getConcept().equals(concept) && (key.getKeyType().equals(KeyType.AUTOUNIQUE) || key.getKeyType().equals(KeyType.UNIQUE))) {
						hasKey = true;
						break;
					}
					
					if (key.getCharacteristic().getType().getName().toString().equals(concept.getName().toString()) && key.getKeyType().equals(KeyType.INDEX)) {
						hasKey = true;
						break;
					}
				}

				if (!hasKey) {
					error("Every concept except root needs a key",
							FeatureLanguagePackage.Literals.CONCEPT__NAME);
				}
			}
		}
	}
	
	@Check
	public void checkNoKeyForRootConcept(Key key) {
		FeatureList featureList = (FeatureList) key.eContainer();
		if (featureList != null) {
			EList<Property> properties = featureList.getProperties();
			for (Property property : properties) {
				if (property instanceof ConceptProperty) {
					if (key.getConcept().equals(property.getConcept())) {
						error("The root concept cannot have a key", FeatureLanguagePackage.Literals.KEY__CONCEPT);
					}
				}
			}
		}
	}

	@Check
	public void checkMultiplicity(Characteristic characteristic) {
		String multiplicity = characteristic.getMultiplicity();
		System.out.println(multiplicity);
		if (multiplicity != null) {
			String[] symbols = multiplicity.split("\\.\\.");
			int from;
			try {
				from = Integer.parseInt(symbols[0]);
			}
			catch (NumberFormatException e) {
				if (symbols[1] != "*") {
					error("Multiplicity's lower bound must be lesser or equal to upper bound",
							FeatureLanguagePackage.Literals.CHARACTERISTIC__NAME);
				}
				return;
			}
			int to;
			try {
				to = Integer.parseInt(symbols[1]);
			}
			catch (NumberFormatException e) {
				return;
			}

			if (from > to) {
				error("Multiplicity's lower bound must be lesser or equal to upper bound",
						FeatureLanguagePackage.Literals.CHARACTERISTIC__NAME);
			}
		}
	}

	@Check
	public void checkExactlyOneRoot(FeatureList featureList) {
		EList<Property> properties = featureList.getProperties();
		boolean hasRoot = false;
		if (properties != null) {
			for (Property property : properties) {
				if (property instanceof ConceptProperty) {
					if (hasRoot) {
						error("There can only be one root", FeatureLanguagePackage.Literals.FEATURE_LIST__PROPERTIES);
					}
					hasRoot = true;
				}
			}
			if (!hasRoot) {
				error("There must be one root", FeatureLanguagePackage.Literals.FEATURE_LIST__PROPERTIES);
			}
		}
	}
	
}
