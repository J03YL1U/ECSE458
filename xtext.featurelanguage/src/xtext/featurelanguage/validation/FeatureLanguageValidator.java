/*
 * generated by Xtext 2.32.0
 */
package xtext.featurelanguage.validation;

import java.util.Arrays;
import java.util.List;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

import xtext.featurelanguage.featureLanguage.Characteristic;
import xtext.featurelanguage.featureLanguage.Concept;
import xtext.featurelanguage.featureLanguage.ConceptProperty;
import xtext.featurelanguage.featureLanguage.FeatureLanguage;
import xtext.featurelanguage.featureLanguage.FeatureLanguagePackage;
import xtext.featurelanguage.featureLanguage.Key;
import xtext.featurelanguage.featureLanguage.KeyType;
import xtext.featurelanguage.featureLanguage.Property;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class FeatureLanguageValidator extends AbstractFeatureLanguageValidator {
	
	List<String> PrimitiveDataTypes = Arrays.asList("int", "byte", "short", "long", "float", "double", "boolean", "char", "String");
	
	@Check
	public void checkOnlyOneKeyPerConcept(Key key) {
		FeatureLanguage featureLanguage = (FeatureLanguage) key.eContainer();

		if (featureLanguage != null) {
			if (key.getKeyType().equals(KeyType.AUTOUNIQUE) || key.getKeyType().equals(KeyType.UNIQUE)) {
				for (Key otherKey : featureLanguage.getKeys()) {
					if (!key.equals(otherKey) && key.getConcept().equals(otherKey.getConcept())) {
						if (!otherKey.getKeyType().equals(KeyType.INDEX)) {
							error("There can only be one key per concept",
									FeatureLanguagePackage.Literals.KEY__CONCEPT);
							break;
						}
					}
				}
			}
			for (Key otherKey : featureLanguage.getKeys()) {
				if (!key.equals(otherKey) && key.getConcept().equals(otherKey.getConcept()) && key.getCharacteristic().equals(otherKey.getCharacteristic())) {
					error("There can only be one key per concept",
							FeatureLanguagePackage.Literals.KEY__CONCEPT);
					break;
				}
				if (!key.equals(otherKey) && key.getConcept().getName().toString().equals(otherKey.getCharacteristic().getType().getName().toString())) {
					error("There can only be one key per concept",
							FeatureLanguagePackage.Literals.KEY__CONCEPT);
					break;
				}
			}
		}
	}
	
	@Check
	public void checkEachIndexKeyHasConcept(Key key) {
		FeatureLanguage featureLanguage = (FeatureLanguage) key.eContainer();

		if (featureLanguage != null) {
			if (key.getKeyType().equals(KeyType.INDEX)) {
				EList<Concept> concepts = featureLanguage.getConcepts();
				boolean hasConcept = false;
				for (Concept concept : concepts) {
					if (key.getCharacteristic().getType().getName().toString().equals(concept.getName().toString())) {
						hasConcept = true;
					}
				}
				if (!hasConcept) {
					error("Every key needs a concept",
							FeatureLanguagePackage.Literals.KEY__CHARACTERISTIC);
				}
			}
		}
	}

	@Check
	public void checkEachConceptButRootHasKey(Concept concept) {
		FeatureLanguage featureLanguage = (FeatureLanguage) concept.eContainer();
		Concept rootConcept = null;
		if (featureLanguage != null) {
			EList<Property> properties = featureLanguage.getProperties();
			for (Property property : properties) {
				if (property instanceof ConceptProperty) {
					rootConcept = property.getConcept();
				}
			}
		}
		if (!concept.equals(rootConcept)) {
			boolean hasKey = false;

			if (featureLanguage != null) {
				for (Key key : featureLanguage.getKeys()) {
					if (key.getConcept().equals(concept) && (key.getKeyType().equals(KeyType.AUTOUNIQUE) || key.getKeyType().equals(KeyType.UNIQUE))) {
						hasKey = true;
						break;
					}
					
					if (key.getCharacteristic().getType().getName().toString().equals(concept.getName().toString()) && key.getKeyType().equals(KeyType.INDEX)) {
						hasKey = true;
						break;
					}
				}

				if (!hasKey) {
					error("Every concept except root needs a key",
							FeatureLanguagePackage.Literals.NAMED_ELEMENT__NAME);
				}
			}
		}
	}
	
	@Check
	public void checkNoKeyForRootConcept(Key key) {
		FeatureLanguage featureLanguage = (FeatureLanguage) key.eContainer();
		if (featureLanguage != null) {
			EList<Property> properties = featureLanguage.getProperties();
			for (Property property : properties) {
				if (property instanceof ConceptProperty) {
					if (key.getConcept().equals(property.getConcept())) {
						error("The root concept cannot have a key", FeatureLanguagePackage.Literals.KEY__CONCEPT);
					}
				}
			}
		}
	}

	@Check
	public void checkMultiplicity(Characteristic characteristic) {
		String multiplicity = characteristic.getMultiplicity();
		System.out.println(multiplicity);
		if (multiplicity != null) {
			String[] symbols = multiplicity.split("\\.\\.");
			int from;
			try {
				from = Integer.parseInt(symbols[0]);
			}
			catch (NumberFormatException e) {
				if (symbols[1] != "*") {
					error("Multiplicity's lower bound must be lesser or equal to upper bound",
							FeatureLanguagePackage.Literals.NAMED_ELEMENT__NAME);
				}
				return;
			}
			int to;
			try {
				to = Integer.parseInt(symbols[1]);
			}
			catch (NumberFormatException e) {
				return;
			}

			if (from > to) {
				error("Multiplicity's lower bound must be lesser or equal to upper bound",
						FeatureLanguagePackage.Literals.NAMED_ELEMENT__NAME);
			}
		}
	}

	@Check
	public void checkExactlyOneRoot(FeatureLanguage featureLanguage) {
		EList<Property> properties = featureLanguage.getProperties();
		boolean hasRoot = false;
		if (properties != null) {
			for (Property property : properties) {
				if (property instanceof ConceptProperty) {
					if (hasRoot) {
						error("There can only be one root", FeatureLanguagePackage.Literals.FEATURE_LANGUAGE__PROPERTIES);
					}
					hasRoot = true;
				}
			}
			if (!hasRoot) {
				error("There must be one root", FeatureLanguagePackage.Literals.FEATURE_LANGUAGE__PROPERTIES);
			}
		}
	}
	
	@Check
	public void checkTypeMakesSense(Characteristic characteristic) {
		FeatureLanguage featureLanguage = (FeatureLanguage) characteristic.eContainer().eContainer();
		
		if (featureLanguage != null) {
			String characteristicType = characteristic.getType().getName().toString();
			if (PrimitiveDataTypes.contains(characteristicType)) {
				if (characteristic.getMultiplicity() != null || characteristic.getLiterals().size() != 0) {
					error("Characteristics with primitive data types cannot have multiplicities nor literals", FeatureLanguagePackage.Literals.CHARACTERISTIC__TYPE);
				}
			}
			else {
				List<Concept> concepts = featureLanguage.getConcepts();
				boolean isConceptType = false;
				for (Concept concept : concepts) {
					if (concept.getName().toString().equals(characteristicType)) {
						isConceptType = true;
						if (characteristic.getMultiplicity() == null) {
							error("Characteristics with Concept data types must have a multiplicity", FeatureLanguagePackage.Literals.CHARACTERISTIC__TYPE);
						}
						break;
					}
				}
				if (!isConceptType) {
					if (characteristic.getLiterals() == null || characteristic.getLiterals().size() == 0) {
						error("Characteristics with enum data types must have literals", FeatureLanguagePackage.Literals.CHARACTERISTIC__TYPE);
					}
				}
			}
		}
	}
}
