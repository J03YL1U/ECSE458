/*
 * generated by Xtext 2.32.0
 */
package my.xtext.featurelist.myfeaturelist.validation;

import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;

import my.xtext.featurelist.myfeaturelist.myFeatureList.Attribute;
import my.xtext.featurelist.myfeaturelist.myFeatureList.Concept;
import my.xtext.featurelist.myfeaturelist.myFeatureList.ConceptProperty;
import my.xtext.featurelist.myfeaturelist.myFeatureList.FeatureList;
import my.xtext.featurelist.myfeaturelist.myFeatureList.Key;
import my.xtext.featurelist.myfeaturelist.myFeatureList.MyFeatureListPackage;
import my.xtext.featurelist.myfeaturelist.myFeatureList.Property;

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
public class MyFeatureListValidator extends AbstractMyFeatureListValidator {

	//	public static final String INVALID_NAME = "invalidName";
	//
	//	@Check
	//	public void checkGreetingStartsWithCapital(Greeting greeting) {
	//		if (!Character.isUpperCase(greeting.getName().charAt(0))) {
	//			warning("Name should start with a capital",
	//					MyFeatureListPackage.Literals.GREETING__NAME,
	//					INVALID_NAME);
	//		}
	//	}

	@Check
	public void checkOnlyOneKeyPerConcept(Key key) {
		FeatureList featureList = (FeatureList) key.eContainer();

		if (featureList != null) {
			for (Key otherKey : featureList.getKeys()) {
				if ( !key.equals(otherKey) && key.getConcept().equals(otherKey.getConcept())) {
					error("There can only be one key per concept",
							MyFeatureListPackage.Literals.KEY__CONCEPT);
					break;
				}
			}
		}
	}

	@Check
	public void checkEachConceptButRootHasKey(Concept concept) {
		FeatureList featureList = (FeatureList) concept.eContainer();
		Concept rootConcept = null;
		if (featureList != null) {
			EList<Property> properties = featureList.getProperties();
			for (Property property : properties) {
				if (property instanceof ConceptProperty) {
					rootConcept = property.getConcept();
				}
			}
		}
		if (!concept.equals(rootConcept)) {
			boolean hasKey = false;

			if (featureList != null) {
				for (Key key : featureList.getKeys()) {
					if (key.getConcept().equals(concept)) {
						hasKey = true;
						break;
					}
				}

				if (!hasKey) {
					error("Every concept except root needs a key",
							MyFeatureListPackage.Literals.CONCEPT__NAME);
				}
			}
		}
	}
	
	@Check
	public void checkNoKeyForRootConcept(Key key) {
		FeatureList featureList = (FeatureList) key.eContainer();
		if (featureList != null) {
			EList<Property> properties = featureList.getProperties();
			for (Property property : properties) {
				if (property instanceof ConceptProperty) {
					if (key.getConcept().equals(property.getConcept())) {
						error("The root concept cannot have a key", MyFeatureListPackage.Literals.KEY__CONCEPT);
					}
				}
			}
		}
	}

	@Check
	public void checkMultiplicity(Attribute attribute) {
		String multiplicity = attribute.getMultiplicity();
		System.out.println(multiplicity);
		if (multiplicity != null) {
			String[] symbols = multiplicity.split("\\.\\.");
			int from;
			try {
				from = Integer.parseInt(symbols[0]);
			}
			catch (NumberFormatException e) {
				if (symbols[1] != "*") {
					error("Multiplicity's lower bound must be lesser or equal to upper bound",
							MyFeatureListPackage.Literals.ATTRIBUTE__NAME);
				}
				return;
			}
			int to;
			try {
				to = Integer.parseInt(symbols[1]);
			}
			catch (NumberFormatException e) {
				return;
			}

			if (from > to) {
				error("Multiplicity's lower bound must be lesser or equal to upper bound",
						MyFeatureListPackage.Literals.ATTRIBUTE__NAME);
			}
		}
	}

	@Check
	public void checkExactlyOneRoot(FeatureList featureList) {
		EList<Property> properties = featureList.getProperties();
		boolean hasRoot = false;
		if (properties != null) {
			for (Property property : properties) {
				if (property instanceof ConceptProperty) {
					if (hasRoot) {
						error("There can only be one root", MyFeatureListPackage.Literals.FEATURE_LIST__PROPERTIES);
					}
					hasRoot = true;
				}
			}
			if (!hasRoot) {
				error("There must be one root", MyFeatureListPackage.Literals.FEATURE_LIST__PROPERTIES);
			}
		}
	}
}
